### Simulating a mixture of compounds, given spin simulation, machine, experimental parameters.

Load required packages and set up random seed.
```julia; results="hidden"
import NMRSpectraSimulator

using LinearAlgebra
using FFTW
import PlotlyJS
using Plots; plotly()
import Statistics
import Random
Random.seed!(25)
```

Two types of parameters: the spin-Hamiltonian simulation and spectrometer/experiment parameters.

Spin-related parameters for the spectrum simulation.

```julia; results="hidden"
# spin-Hamiltonian-related.
tol_coherence = 1e-2 # resonances are pairs of eigenvalues of the Hamiltonian that have quantum numbers that differ by -1. This is the tolerance away from -1 that is allowed.
α_relative_threshold = 0.05 # resonances with relative amplitude less than this factor compared to the maximum resonance in the spin group will be removed. Set to 0.0 to see every single resonance component.
Δc_partition_radius = 0.17 # determines how many resonances get grouped together. Larger number means less groups and thus more resonances per group.

# surrogate-related.
Δcs_max = 0.2 # In units of ppm. interpolation border that is added to the lowest and highest resonance frequency component of the mixture being simulated.
κ_λ_lb = 0.5 # interpolation lower limit for κ_λ.
κ_λ_ub = 2.5 # interpolation upper limit for κ_λ.

# experiment-related parameters
λ0 = 3.4
ν_0ppm = 10656.011933076665 # where the 0 ppm reference freuency should be, in Hz.

# spectrometer parameters
fs = 14005.602240896402 # sampling frequency, in Hz.
SW = 20.0041938620844 # spectral window, in ppm. Described in Bruker
```
The local surrogate model fits spline interpolators over the following variables, with their corresponding interpolation domain interval:
```
r in [u_min, u_max] # we'll defined u_min and u_max later.
λ in [κ_λ_lb*λ0, κ_λ_ub*λ0]
λ0 is the resonance component at the 0 ppm frequency reference.
```



Spectrometer and experiment-related parameters can be obtained from a given NMR experiment from the [NMRDataSetup.jl](https://github.com/AI4DBiological-Systems/NMRDataSetup.jl) package. The values provided here were taken from an experiment from the BMRB database, and resembles a typical 1D 1H NMR spectrometer and experiment.



NMR spectroscopy uses ppm as the frequency unit. The physics simulation use frequency units in Hz. The following are the conversion formulae that are used by the routines of this Julia package:
```julia; results="hidden"
hz2ppmfunc = uu->(uu - ν_0ppm)*SW/fs
ppm2hzfunc = pp->(ν_0ppm + pp*fs/SW)
```

We need to provide the path to the location of the [/src/input/molcules](https://github.com/AI4DBiological-Systems/NMRData/tree/main/input/molecules) in the [NMRData.jl](https://github.com/AI4DBiological-Systems/NMRData) repository. This folder contain the JLD files that contain J-coupling and chemical shift constants from the [GISSMO library](http://gissmo.nmrfam.wisc.edu/library).

```julia; results="hidden"
H_params_path = "/home/roy/Documents/repo/NMRData/input/coupling_info"
```
Note that the chemical shift tend to change slightly (within +/- 0.1 ppm) for every NMR experiment. The J-coupling constants for a compound shouldn't change in theory, but the values provided by the GISSMO library are empirically fitted, thus prone to misfit error and physics model descrepancy. In [NMRCalibrate.jl](https://github.com/AI4DBiological-Systems/NMRCalibrate.jl), we work on the fitting of the simulated spectra (provided in this package) to NMR experiment data.



Let's simulate following compounds:
```julia; results="hidden"
molecule_names = ["L-Serine"; "L-Phenylalanine"; "DSS";]
```
See [GISSMOReader.jl](https://github.com/AI4DBiological-Systems/GISSMOReader.jl) for the current list of feasible compounds.


Setup our proposed signal model of our specified compounds, and allocate the data structure that contain the surrogate and model parameters.

```julia; results="hidden"
Δcs_max_mixture = collect( Δcs_max for i = 1:length(molecule_names)) # TODO: verify if this is still used in the latest version.

dummy_SSFID = NMRSpectraSimulator.SpinSysParamsType1(0.0);
mixture_params = NMRSpectraSimulator.setupmixtureproxies(molecule_names,
    H_params_path, ppm2hzfunc, fs, SW, λ0,
    ν_0ppm, dummy_SSFID;
    tol_coherence = tol_coherence,
    α_relative_threshold = α_relative_threshold);
As = mixture_params
```
We will describe the datatype of `As[n]` in the (forthcoming) API document.


Fit the local surrogate models to the proposed modified FFID model.
Provide the frequency interval to build the local surrogate models. We'll just use the same interval for all the compounds.

```julia; results="hidden"
u_min = ppm2hzfunc(-0.5)
u_max = ppm2hzfunc(4.0)

NMRSpectraSimulator.fitproxies!(As;
    κ_λ_lb = κ_λ_lb,
    κ_λ_ub = κ_λ_ub,
    u_min = u_min,
    u_max = u_max,
     Δr = 1.0, # the samples used to build the surrogate is taken every 1 radian on the frequency axis. Decrease for improved accuracy at the expense of computation resources.
    Δκ_λ = 0.05) # the samples used to build thes urrogate for κ_λ are taken at this sampling spacing. Decrease for improved accuracy at the expense of computation resources.
```
The interpolation fitting sampling interval for the $r$ argument of the local surrogate model is given by `Δr`, and similarly for the $h$ argument and `Δκ_λ`. See the Background section for the $r$ and $h$ arguments.


Our proposed modified FFID model for the entire mixture of compounds:
```julia; results = "hidden"
f = uu->NMRSpectraSimulator.evalmixture(uu, mixture_params)
```

It's surrogate:
```julia; results = "hidden"
q = uu->NMRSpectraSimulator.evalitpproxymixture(uu, mixture_params)
```


Prepare visualization.
```julia; results = "hidden"
P = LinRange(hz2ppmfunc(u_min), hz2ppmfunc(u_max), 50000)
U = ppm2hzfunc.(P)
U_rad = U .* (2*π)

f_U = f.(U_rad)
q_U = q.(U_rad)
```

The l-2 discrepancy between the models `f` (the $g_{mFFID}$ function) and its surrogate `q` over the frequency locations in `U`.
```julia
discrepancy = abs.(f_U-q_U)
max_val, ind = findmax(discrepancy)
println("relative discrepancy = ", norm(discrepancy)/norm(f_U))
println("max discrepancy: ", max_val)
println()
```


```julia; fig_cap=""

# real.
display_mat = [ real.(f_U) real.(q_U) ]
display_labels = ["proposed model" "spline surrogate"]

default(titlefont = (16, "times"), legendfontsize = 14, guidefont = (16, :black),
tickfont = (12, :black))
plot_handle = plot(P, display_mat,
labels = display_labels,
title = "Simulated Spectrum: $(join(molecule_names, ", "))",
xlabel = "ppm",
ylabel = "real part of spectrum",
xflip = true,
linewidth = 2, legend = :topright, size = (1000,400))

display(plot_handle)


# imaginary.
display_mat = [ imag.(f_U) imag.(q_U) ]
display_labels = ["proposed model" "spline surrogate"]

default(titlefont = (16, "times"), legendfontsize = 14, guidefont = (16, :black),
tickfont = (12, :black))
plot_handle = plot(P, display_mat,
labels = display_labels,
title = "Simulated Spectrum: $(join(molecule_names, ", "))",
xlabel = "ppm",
ylabel = "imaginary part of spectrum",
xflip = true,
linewidth = 2, legend = :topright, size = (1000,400))

display(plot_handle)


# magnitude.
display_mat = [ abs.(f_U) abs.(q_U) ]
display_labels = ["proposed model" "spline surrogate"]

default(titlefont = (16, "times"), legendfontsize = 14, guidefont = (16, :black),
tickfont = (12, :black))
plot_handle = plot(P, display_mat,
labels = display_labels,
title = "Simulated Spectrum: $(join(molecule_names, ", "))",
xlabel = "ppm",
ylabel = "magnitude part of spectrum",
xflip = true,
linewidth = 2, legend = :topright, size = (1000,400))

display(plot_handle)
```


Now, show the effect of parameter values on the spectra. Purposely distort the spectra by assigning random values to model parameters.
```julia; results="hidden"
Ag = As[1]
Ag.ss_params.d = rand(length(Ag.ss_params.d))
Ag.ss_params.κs_λ = rand(length(Ag.ss_params.κs_λ)) .+ 1
Ag.ss_params.κs_β = collect( rand(length(Ag.ss_params.κs_β[i])) .* (2*π) for i = 1:length(Ag.ss_params.κs_β) )
```
This mutates `mixture_params`, aka `As`.


Re-evaluate at evaluation locations, and plot. Plotting code is hidden.

```julia; fig_cap=""; results="hidden"

f_U = f.(U_rad)
q_U = q.(U_rad)

inds = findall(xx->(2.5<xx<4), P)
```

```julia; fig_cap=""; echo=false
# real.
display_mat = [ real.(f_U[inds]) real.(q_U[inds]) ]
display_labels = ["proposed model" "spline surrogate"]

default(titlefont = (16, "times"), legendfontsize = 14, guidefont = (16, :black),
tickfont = (12, :black))
plot_handle = plot(P[inds], display_mat,
labels = display_labels,
title = "Simulated Spectrum: $(join(molecule_names, ", "))",
xlabel = "ppm",
ylabel = "real part of spectrum",
xflip = true,
linewidth = 2, legend = :topright, size = (1000,400))

display(plot_handle)


# imaginary.
display_mat = [ imag.(f_U[inds]) imag.(q_U[inds]) ]
display_labels = ["proposed model" "spline surrogate"]

default(titlefont = (16, "times"), legendfontsize = 14, guidefont = (16, :black),
tickfont = (12, :black))
plot_handle = plot(P[inds], display_mat,
labels = display_labels,
title = "Simulated Spectrum: $(join(molecule_names, ", "))",
xlabel = "ppm",
ylabel = "imaginary part of spectrum",
xflip = true,
linewidth = 2, legend = :topright, size = (1000,400))

display(plot_handle)


# magnitude.
display_mat = [ abs.(f_U[inds]) abs.(q_U)[inds] ]
display_labels = ["proposed model" "spline surrogate"]

default(titlefont = (16, "times"), legendfontsize = 14, guidefont = (16, :black),
tickfont = (12, :black))
plot_handle = plot(P[inds], display_mat,
labels = display_labels,
title = "Simulated Spectrum: $(join(molecule_names, ", "))",
xlabel = "ppm",
ylabel = "magnitude part of spectrum",
xflip = true,
linewidth = 2, legend = :topright, size = (1000,400))

display(plot_handle)
```
